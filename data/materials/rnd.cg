
struct iVIn
{
	float4 p	: POSITION;
	float2 uv   : TEXCOORD0;
};
struct iVOut
{
	float4 p	: POSITION;
	float2 uv	: TEXCOORD0;
};


iVOut rnd_vs(iVIn IN,
	uniform float4x4 wvpMat)
{
	iVOut OUT;  OUT.uv = IN.uv;
	OUT.p = mul(wvpMat, IN.p);
	return OUT;
}


float4 rnd_ps(in float2 uv : TEXCOORD0,
	uniform sampler2D diffuseMap : TEXUNIT0): COLOR0
{
	return tex2D(diffuseMap, uv);
}


//  rot, inv
float4 rnd_inv_ps(in float2 uv : TEXCOORD0,
	uniform sampler2D diffuseMap : TEXUNIT0): COLOR0
{
	float2 uv2 = float2(uv.y, 1.f - uv.x);  // rotate 90'
	return float4(1,1,1,0) -/**/ tex2D(diffuseMap, uv2);  // inverse
}


//  add 2 tex
float4 rnd_add_ps(in float2 uv : TEXCOORD0,
	uniform sampler2D diffuseAdd : TEXUNIT0,
	uniform sampler2D diffuseMap : TEXUNIT1): COLOR0
{
	float4 rd = tex2D(diffuseAdd, uv);
	float4 ter = tex2D(diffuseMap, uv);
	return float4(lerp(rd.rgb, ter.rgb, 1-rd.a), 1);
}


//  select overlay
float4 sel_ps(uniform float fTime): COLOR0
{
	// float3(0.09, 0.17, 0.26)
	float3 clr = float3(0.14, 0.22, 0.36) * (0.5f + 0.1f * cos(3.f * fTime));
	return float4(clr, 1);
}


//  zoomed minimap circle  ----------------------

struct CIn
{
	float4 p	: POSITION;
	float2 uv   : TEXCOORD0;
	float4 clr  : COLOR;
};
struct COut
{
	float4 p	: POSITION;
	float2 uv	: TEXCOORD0;
	float4 clr  : COLOR;
};

COut circle_vs(CIn IN,
	uniform float4x4 wvpMat)
{
	COut OUT;  OUT.uv = IN.uv;  OUT.clr = IN.clr;
	OUT.p = mul(wvpMat, IN.p);
	return OUT;
}

float4 circle_ps(in float2 uv : TEXCOORD0,
				in float4 clr : COLOR,  // tc 0..1
	uniform sampler2D diffuseMap : TEXUNIT0,
	uniform sampler2D circleMap : TEXUNIT1): COLOR0
{
	float4 tex = tex2D(diffuseMap, uv);
	float4 cir = tex2D(circleMap, clr.xy);

	float a = tex.a * lerp(1, cir.b, clr.z);
	return float4(tex.rgb, a);
}
