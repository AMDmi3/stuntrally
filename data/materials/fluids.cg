//-------------------------------------------------------
struct VIn
{
	float4 p : POSITION;	float3 n : NORMAL;
	float3 t : TANGENT;		float3 uv: TEXCOORD0;
};
struct VOut
{
	float4 p : POSITION;	float3 uv : TEXCOORD0;	float4 wp : TEXCOORD1;
	float3 n : TEXCOORD2;	float3 t  : TEXCOORD3;	float3 b  : TEXCOORD4;
};
struct PIn
{	float4 p : POSITION;	float3 uv : TEXCOORD0;	float4 wp : TEXCOORD1;
	float3 n : TEXCOORD2;	float3 t  : TEXCOORD3;	float3 b  : TEXCOORD4;
};


//-------------------------------------------------  ppx  vs
VOut water1_vs(VIn IN,
	uniform float4x4 wMat,  uniform float4x4 wvpMat,
	uniform float4 fogParams)
{
	VOut OUT;  OUT.uv = IN.uv;
	OUT.wp = mul(wMat, IN.p);
	OUT.p = mul(wvpMat, IN.p);
	OUT.n = IN.n;  OUT.t = IN.t;  OUT.b = cross(IN.t, IN.n);
	OUT.wp.w = saturate(fogParams.x * (OUT.p.z - fogParams.y) * fogParams.w);
	return OUT;
}


//-------------------------------------------------  ppx water  -------------------------------------------------
float4 water1_ps(PIn IN,       ///  _water_
	//uniform float3 lightDif0,
    uniform float3 lightSpec0,
	//uniform float4 matDif,
	uniform float4 matSpec,	uniform float matShininess,
	uniform float3 fogColor,
	uniform float4 lightPos0,  uniform float3 camPos,	uniform float4x4 iTWMat,

	uniform float2 waveBump,
	uniform float waveHighFreq, uniform float waveSpecular,
	uniform float fTime,
	uniform float4 deepColor,  uniform float4 shallowColor,  uniform float4 reflectionColor,
	uniform float2 reflAndWaterAmounts,
	uniform float2 fresnelPowerBias,

	uniform sampler2D normalMap : TEXUNIT0,
	uniform sampler2D skyMap : TEXUNIT1): COLOR0
{
	float t = waveBump.y * fTime;

	//  waves  sum 4 normal tex
	float2 uv1 = float2(-sin(-0.06f * t),cos(-0.06f * t)) * 0.5f;  // slow big waves
	float2 uv2 = float2( cos( 0.062f* t),sin( 0.062f* t)) * 0.4f;
	float2 uw1 = float2(-sin(-0.11f * t),cos(-0.11f * t)) * 0.23f;  // fast small waves
	float2 uw2 = float2( cos( 0.112f* t),sin( 0.112f* t)) * 0.21f;

	const float w1 = 0.25 + waveHighFreq, w2 = 0.25 - waveHighFreq;
	float3 normalTex = (
		(tex2D(normalMap, IN.uv.xy*8 - uw2).rgb * 2.0 - 1.0) * w1 +
		(tex2D(normalMap, IN.uv.xy*8 - uw1).rgb * 2.0 - 1.0) * w1 +
		(tex2D(normalMap, IN.uv.xy*2 + uv1).rgb * 2.0 - 1.0) * w2 +
		(tex2D(normalMap, IN.uv.xy*2 + uv2).rgb * 2.0 - 1.0) * w2);
	normalTex = lerp(normalTex, float3(0,0,1), waveBump.x);


	//  normal to object space
	float3x3 tbn = float3x3(IN.t, IN.b, IN.n);
	float3 normal = mul(transpose(tbn), normalTex.xyz);
	normal = normalize(mul((float3x3)iTWMat, normal));
	//normal = float3(0,1,0);
	//return float4(normal, 1);  // test


	//  diffuse, specular
	float3 ldir = normalize(lightPos0.xyz - (lightPos0.w * IN.wp.xyz));
	//float3 diffuse = pow(max(dot(ldir, normal), 0), alphaPars.w);
	float3 camDir = normalize(camPos - IN.wp.xyz);
	float3 halfVec = normalize(ldir + camDir);
	float3 specular = pow(max(dot(normal, halfVec), 0), matShininess);

	//float3 diffC = diffuse * lightDif0 * matDif.rgb;
	float3 specC = specular * lightSpec0 * matSpec.rgb;
	float3 clrSUM = /*diffC +*/ specC;


	//  reflection  3D vec to sky dome map 2D uv
	float3 refl = reflect(-camDir, normal);
	const float PI = 3.14159265358979323846;
	float2 refl2;
	refl2.x = /*(refl.x == 0) ? 0 :*/ ( (refl.z < 0.0) ? atan2(-refl.z, refl.x) : (2*PI - atan2(refl.z, refl.x)) );
	refl2.x = 1 - refl2.x / (2*PI);  // yaw 0..1
	refl2.y = 1 - asin(refl.y) / PI*2;  //pitch 0..1
	//return float4(refl2.x,0,refl2.y,1);
	float4 reflection = tex2D(skyMap, refl2) * reflectionColor;


	//  fresnel
	float facing = 1.0 - max(abs(dot(camDir, normal)), 0);
	float fresnel = saturate(fresnelPowerBias.y + pow(facing, fresnelPowerBias.x));
	//float fresnel = fresnelPowerBias.y + fresnelScale * pow(1 + dot(eyeDir, normal), fresnelPowerBias.x);
	//return float4(float3(0,1,0)*fresnel,1);


	//  water color
	float4 waterClr = lerp(shallowColor, deepColor, facing);
	float4 reflClr = lerp(waterClr, reflection, fresnel);

	float3 clr = clrSUM.rgb * waveSpecular + waterClr.rgb * reflAndWaterAmounts.y + reflClr.rgb * reflAndWaterAmounts.x;
	clr = lerp(clr, fogColor, /*IN.fogVal*/IN.wp.w);
	return float4(clr, waterClr.a + clrSUM.r);
}
