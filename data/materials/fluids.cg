//-------------------------------------------------------
struct VIn
{
	float4 p : POSITION;	float3 n : NORMAL;
	float3 t : TANGENT;		float3 uv: TEXCOORD0;
	float4 c : COLOR;
};
struct VOut
{
	float4 p : POSITION;	float3 uv : TEXCOORD0;	float4 wp : TEXCOORD1;
	float3 n : TEXCOORD2;	float3 t  : TEXCOORD3;	float3 b  : TEXCOORD4;
	float3 eye : TEXCOORD5;
	float4 c : COLOR;
};
struct PIn
{							float3 uv : TEXCOORD0;	float4 wp : TEXCOORD1;
	float3 n : TEXCOORD2;	float3 t  : TEXCOORD3;	float3 b  : TEXCOORD4;
	float3 eye : TEXCOORD5;
	float4 c : COLOR;
};


//-------------------------------------------------  ppx  vs
VOut water1_vs(VIn IN,
	uniform float4x4 wMat,  uniform float4x4 wvpMat,
	uniform float3 eyePos,	uniform float4 fogParams)
{
	VOut OUT;  OUT.uv = IN.uv;
	OUT.wp = mul(wMat, IN.p);
	OUT.p = mul(wvpMat, IN.p);
	OUT.n = IN.n;  OUT.t = IN.t;  OUT.b = cross(IN.t, IN.n);
	OUT.c = IN.c;  //clr
	OUT.wp.w = saturate(fogParams.x * (OUT.p.z - fogParams.y) * fogParams.w);
	OUT.eye = normalize(IN.p.xyz - eyePos);  // eye position in vertex space
	return OUT;
}


//-------------------------------------------------  ppx water  -------------------------------------------------
float4 water1_ps(PIn IN,       ///  _water_
	uniform float4 alphaPars,
	uniform float fTime,
	uniform float3 ambient,  uniform float3 lightDif0,  uniform float3 lightSpec0,
	uniform float4 matDif,   uniform float4 matSpec,	uniform float matShininess,
	uniform float3 fogColor,
	uniform float4 lightPos0,  uniform float3 camPos,
	uniform float4 invSMSize,  uniform float4x4 iTWMat,

	uniform float4 deepColor,		uniform float4 shallowColor,
	uniform float4 reflectionColor,	uniform float reflectionAmount,
	uniform float reflectionBlur,	uniform float waterAmount,
	uniform float fresnelPower,		uniform float fresnelBias,

	uniform sampler2D diffuseMap : TEXUNIT0,
	uniform sampler2D normalMap : TEXUNIT1,
	uniform samplerCUBE envMap : TEXUNIT2): COLOR0
{
	float3 ldir = normalize(lightPos0.xyz - (lightPos0.w * IN.wp.xyz));

	//  sum 4 normal tex
	float2 uv1 = float2(-sin(-0.06f * fTime),cos(-0.06f * fTime))*0.5f;  // slow big waves
	float2 uv2 = float2( cos( 0.062f* fTime),sin( 0.062f* fTime))*0.4f;
	float2 uw1 = float2(-sin(-0.11f * fTime),cos(-0.11f * fTime))*0.23f;  // fast small waves
	float2 uw2 = float2( cos( 0.112f* fTime),sin( 0.112f* fTime))*0.21f;

	float3 normalTex = normalize(
		tex2D(normalMap, IN.uv.xy*8 - uw2).rgb *
		tex2D(normalMap, IN.uv.xy*8 - uw1).rgb *0.7 +
		tex2D(normalMap, IN.uv.xy*2 + uv1).rgb *
		tex2D(normalMap, IN.uv.xy*2 + uv2).rgb);

	//  normal to object space
	float3x3 tbn = float3x3(IN.t, IN.b, IN.n);
	float3 normal = mul(transpose(tbn), normalTex.xyz * 2.f - 1.f);
	normal = normalize(mul((float3x3)iTWMat, normal));

	float3 diffuse = pow(max(dot(ldir, normal), 0), alphaPars.w);

	float3 camDir = normalize(camPos - IN.wp.xyz);
	float3 halfVec = normalize(ldir + camDir);
	float3 specular = pow(max(dot(normal, halfVec), 0), matShininess);

	float4 diffuseTex = tex2D(diffuseMap, IN.uv.xy);

	float3 diffC = diffuse * lightDif0 */*?*/ matDif.rgb  * diffuseTex.rgb;
	float3 specC = specular * lightSpec0 * matSpec.rgb;
	float3 clrSUM = diffuseTex.rgb * ambient + diffC + specC;
 
	clrSUM = lerp(clrSUM, fogColor, /*IN.fogVal*/IN.wp.w);
	//return float4(normal, 1);  // test
	float4 clrSpec = float4(clrSUM, alphaPars.x + alphaPars.y * diffuse.r + alphaPars.z * specular.r);
	return clrSpec;

	//  reflection
    float3 eye = normalize(IN.eye);
    float4 R;
    R.xyz = reflect(eye, normal);
    R.z = -R.z;   R.w = reflectionBlur;
    //float4 reflection = texCUBEbias(envMap, R);
	float4 reflection = texCUBE(envMap, reflect(-camDir, normal) );

	//  fresnel
    float facing = 1.0 - max(dot(camDir, normal), 0);
    float fresnel = saturate(fresnelBias + pow(facing, fresnelPower));
	//float fresnel = fresnelBias + fresnelScale * pow(1 + dot(eyeDir, normal), fresnelPower);

    float4 waterColor = lerp(shallowColor, deepColor, facing) * waterAmount;

    //reflection = lerp(waterColor,  reflection * reflectionColor, fresnel) * reflectionAmount;
    float4 clr = /*waterColor +*/ reflection;
    return float4(clrSpec.rgb + clr.rgb, clrSpec.a + fresnel)*0.001 + reflection*0.0001 + float4(float3(1,1,1)*fresnel,1);
}