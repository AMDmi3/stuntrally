/*********************************************************************NVMH3****
Copyright NVIDIA Corporation 2003
TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAW, THIS SOFTWARE IS PROVIDED
*AS IS* AND NVIDIA AND ITS SUPPLIERS DISCLAIM ALL WARRANTIES, EITHER EXPRESS
OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL NVIDIA OR ITS SUPPLIERS
BE LIABLE FOR ANY SPECIAL, INCIDENTAL, INDIRECT, OR CONSEQUENTIAL DAMAGES
WHATSOEVER (INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF BUSINESS PROFITS,
BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY OTHER PECUNIARY LOSS)
ARISING OUT OF THE USE OF OR INABILITY TO USE THIS SOFTWARE, EVEN IF NVIDIA HAS
BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

Comments:
	Simple ocean shader with animated bump map and geometric waves
	Based partly on "Effective Water Simulation From Physical Models", GPU Gems

11 Aug 05: heavily modified by Jeff Doyle (nfz) for Ogre
02 Sep 11: modified by Crystal Hammer for SR

******************************************************************************/


struct VSin {
	float4 Position : POSITION;   // in object space
	float2 TexCoord : TEXCOORD0;
};
struct VSout {
	float4 Position  : POSITION;  // in clip space  // transform from tangent to obj space
	float3 rotMatrix1 : TEXCOORD0;  float3 rotMatrix2 : TEXCOORD1;  float3 rotMatrix3 : TEXCOORD2;
	float2 bumpCoord0 : TEXCOORD3;  float2 bumpCoord1 : TEXCOORD4;  float2 bumpCoord2 : TEXCOORD5;
	float3 eyeVector  : TEXCOORD6;
};
struct PSin {
	float4 Position  : POSITION;  // in clip space	// transform from tangent to obj space
	float3 rotMatrix1 : TEXCOORD0;  float3 rotMatrix2 : TEXCOORD1;  float3 rotMatrix3 : TEXCOORD2;
	float2 bumpCoord0 : TEXCOORD3;  float2 bumpCoord1 : TEXCOORD4;  float2 bumpCoord2 : TEXCOORD5;
	float3 eyeVector  : TEXCOORD6;
};


// wave functions
struct Wave
{
	float freq;  // 2*PI / wavelength
	float amp;   // amplitude
	float phase; // speed * 2*PI / wavelength
	float2 dir;
};


VSout ocean_vs(VSin IN,
		uniform float4x4 WorldViewProj,
		uniform float3 eyePosition,
		uniform float BumpScale,
		uniform float2 textureScale,
		uniform float2 bumpSpeed,
		uniform float time,
		uniform float waveFreq,
		uniform float waveAmp)
{
	VSout OUT;

	/*#define NWAVES 2
	Wave wave[NWAVES] = {
		{ 1.0, 1.0, 0.5, float2(-1, 0) },
		{ 2.0, 0.5, 1.7, float2(-0.7, 0.7) }
	};

    wave[0].freq = waveFreq;		wave[0].amp = waveAmp;
    wave[1].freq = waveFreq * 3.0;	wave[1].amp = waveAmp * 0.33;
	*/
    float4 P = IN.Position;

	// sum waves
	float ddx = 0.0, ddy = 0.0;
	/*float deriv, angle;

	// wave synthesis using two sine waves at different frequencies and phase shift
	for(int i = 0; i<NWAVES; ++i)
	{
		angle = dot(wave[i].dir, P.xz) * wave[i].freq + time * wave[i].phase;
		P.y += wave[i].amp * sin( angle );
		// calculate derivate of wave function
		deriv = wave[i].freq * wave[i].amp * cos(angle);
		ddx -= deriv * wave[i].dir.x;
		ddy -= deriv * wave[i].dir.y;
	}*/

	// compute the 3x3 tranform from tangent space to object space
	OUT.rotMatrix1.xyz = BumpScale * normalize(float3(1, ddy, 0)); // Binormal
	OUT.rotMatrix2.xyz = BumpScale * normalize(float3(0, ddx, 1)); // Tangent
	OUT.rotMatrix3.xyz = normalize(float3(ddx, 1, ddy)); // Normal

	OUT.Position = mul(WorldViewProj, P);

	// calculate texture coordinates for normal map lookup
	//OUT.bumpCoord0.xy = IN.TexCoord;
	OUT.bumpCoord0.xy = IN.TexCoord*textureScale + time * bumpSpeed;
	OUT.bumpCoord1.xy = IN.TexCoord*textureScale * 2.0 + time * bumpSpeed * 4.0;
	OUT.bumpCoord2.xy = IN.TexCoord*textureScale * 4.0 + time * bumpSpeed * 8.0;

	OUT.eyeVector = P.xyz - eyePosition; // eye position in vertex space
	return OUT;
}



float4 ocean_ps(PSin IN,
		uniform sampler2D NormalMap,
		uniform samplerCUBE EnvironmentMap,
		uniform float time,
		uniform float4 deepColor,
		uniform float4 shallowColor,
		uniform float4 reflectionColor,
		uniform float reflectionAmount,
		uniform float reflectionBlur,
		uniform float waterAmount,
		uniform float fresnelPower,
		uniform float fresnelBias
		) : COLOR
{
	// sum normal maps
	// sample from 3 different points so no texture repetition is noticeable
	//  sum 2 normal tex
	/**/
	float2 uv1 = float2(-sin(-0.06f * time),cos(-0.06f * time))*0.5f;  // slow big waves
	float2 uv2 = float2( cos( 0.062f* time),sin( 0.062f* time))*0.4f;
	float2 uw1 = float2(-sin(-0.11f * time),cos(-0.11f * time))*0.23f;  // fast small waves
	float2 uw2 = float2( cos( 0.112f* time),sin( 0.112f* time))*0.21f;

	float3 N = /*normalize*/(
		tex2D(NormalMap, IN.bumpCoord0.xy*8 - uw2).rgb *
		tex2D(NormalMap, IN.bumpCoord0.xy*8 - uw1).rgb *0.7 +
		tex2D(NormalMap, IN.bumpCoord0.xy*2 + uv1).rgb *
		tex2D(NormalMap, IN.bumpCoord0.xy*2 + uv2).rgb);
	/**
    float3 t0 = tex2D(NormalMap, IN.bumpCoord0).xyz * 2.0 - 1.0;
    float3 t1 = tex2D(NormalMap, IN.bumpCoord1).xyz * 2.0 - 1.0;
    float3 t2 = tex2D(NormalMap, IN.bumpCoord2).xyz * 2.0 - 1.0;
    float3 N = t0 + t1 + t2;
    /**/

    float3x3 m; // tangent to world matrix
    m[0] = IN.rotMatrix1;  m[1] = IN.rotMatrix2;  m[2] = IN.rotMatrix3;
    N = normalize( mul( N, m ) );

	// reflection
    float3 E = normalize(IN.eyeVector);
    float4 R;    R.xyz = reflect(E, N);    R.z = -R.z;    R.w = reflectionBlur;
    float4 reflection = texCUBEbias(EnvironmentMap, R) * reflectionColor;

	// fresnel
    float facing = 1.0 - max(dot(-E, N), 0);
    float fresnel = saturate(fresnelBias + pow(facing, fresnelPower));

    float4 waterClr = lerp(shallowColor, deepColor, facing);
	float4 reflClr = lerp(waterClr, reflection, fresnel);

    float3 clr = waterClr.rgb * waterAmount + reflClr.rgb * reflectionAmount;
    return float4(clr, waterClr.a);  //float4(/*clr.rgb */ E, 1)*0.001 + float4(fresnel,fresnel,fresnel,1);
}
